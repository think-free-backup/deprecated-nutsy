
/* *********************************************************** 
 *
 *  Description : unified socket is a wrapper on socket.io
 *                and proper tcp protocol that accept both  
 *                connection type with the same callback
 *  Author : Christophe Meurice
 *
 ************************************************************ */

// ## Requires

var io;
var net;
var options;
var log = require("../../lib/lib-log")

// ## Internal variables

var m_clientList = [];
var m_messageCallback = null;
var m_connectionCallback = null;
var m_disconnectCallback = null;
var m_usessl;

// ## Client socket definition

var Client = function(host, port, socketType, socket){

    var me = this;
    var m_host = host;
    var m_port = port;
    var m_socketType = socketType;
    var m_socket = socket;
    var m_timer;
    var allowed = false;
    var heartbeat = 5000;

    this.host = function (){return m_host};
    this.port = function (){return m_port};
    this.uuid = "";
    this.ssid = "";
    this.remainingString = "";

    /* Client timeout */
    
    if (m_socketType === "tcp"){

        console.log("Starting heartbeat client timeout");
        m_timer = setTimeout(timeout,10000);
    }
    
    /* Communication */ 

    this.send = function (data){

        if (m_socketType === "tcp" ){
            var str;

            if (typeof data === "string")
                str = data;
            else
                str = JSON.stringify(data);

            try{
                if( m_socket.writable ){
                    m_socket.write(":::0:::" + str + ":::1:::");   
                }
                else{
                    console.log("[AcuitySocket::send] " + "Socket not writable") ;
                    m_socket.destroy();
                }
            }
            catch (err){
                console.log("[AcuitySocket::send] " + err);
            }
            
        }
        else if (m_socketType === "web"){
            try{

                m_socket.json.send(data);    
            }
            catch(err){

                console.log("Can't write to socket");
            }
            
        }
    }

    this.broadcastToNodes = function (nodes, data){

        for (var c in m_clientList){

            console.log("Node : " + m_clientList[c].ssid)
            
            if (nodes.indexOf(m_clientList[c].ssid) != -1) {
                console.log("    |-> Brodcasting to this node");
                m_clientList[c].send(data);
            }
        }
    }

    this.broadcast = function (data){

        for (var c in m_clientList){
            m_clientList[c].send(data);
        }
    }

    this.resetTimeout = function(){

        clearTimeout(m_timer);
        m_timer = setTimeout(timeout,heartbeat);
    }

    this.setHeartbeat = function (hb) {

        heartbeat = hb;
        clearTimeout(m_timer);
        m_timer = setTimeout(timeout,heartbeat);
    };


    this.closeConnection = function (){

        m_socket.destroy();
    }

    function timeout(){
        console.log("Hearthbeat not received");
        m_socket.destroy();
    }
};

// ## Create server

exports.init = function(usessl){

    m_usessl = usessl;
    
    io = require('socket.io');

    if (usessl){
        net = require('tls');
        var fs = require('fs');

        options = {
            key: fs.readFileSync('server.key'),
            cert: fs.readFileSync('cert.pem')
        };
    }
    else{

        net = require('net');
    }
}

exports.connect = function(socketioPort, socketPort) {

    // Creating socket.io server
    // /////////////////////////

    if (socketioPort !== 0){

        var app = require('http').createServer();
        app.listen(socketioPort);

        var sio = io.listen(app);

        sio.set('transports', ['websocket', 'jsonp-polling']); // xhr-polling

        sio.sockets.on('connection',function(socket){

            var client = new Client(socket.handshake.address.address, socket.handshake.address.port, "web", socket);
            m_clientList[socket.handshake.address.address + ":" + socket.handshake.address.port] = client;

            if (m_connectionCallback !== undefined){
                m_connectionCallback(client);
            }

            socket.on('message', function (json) {
                if (m_messageCallback !== undefined){
                    m_messageCallback(client,json);
                }
            });

            socket.on('disconnect', function () {
                
                if (m_disconnectCallback !== undefined){
                    m_disconnectCallback(m_clientList[socket.handshake.address.address + ":" + socket.handshake.address.port]);
                }
                else{
                    console.log('Client disconnected : ' + socket.handshake.address.address + " : " + socket.handshake.address.port);
                }

                delete m_clientList[socket.handshake.address.address + ":" + socket.handshake.address.port];

            });
        });
    }

    // Creating TCP server
    // /////////////////////////

    if (socketPort !== 0){

       if (m_usessl)
           net.createServer(options,clientConnected).listen(socketPort, "0.0.0.0");
       else
           net.createServer(clientConnected).listen(socketPort, "0.0.0.0");

       // Tcp client connected
       function clientConnected(sock) {

           sock.setEncoding('utf8');

           var client = new Client(sock.remoteAddress, sock.remotePort, "tcp", sock);
           m_clientList[sock.remoteAddress + ":" + sock.remotePort] = client;

           if (m_connectionCallback !== undefined){

               m_connectionCallback(client);
           }

           sock.on('data', function(dt) {
               
               if(client.remainingString !== ""){
                    
                   dt = client.remainingString + dt;
                   client.remainingString = "";
               }

               var dataArray = dt.split(":::0:::");

               for (var idx in dataArray){
                   var value = dataArray[idx];
                   
                   if (value !== ""){

                        if(value.indexOf(":::1:::") !== -1){

                            dataReceived(value.split(":::1:::")[0],client);
                        }
                        else{
                            
                            console.log("Warning : data received didn't contains trailling :::1:::");
                            client.remainingString = value;
                        }
                   }
               }
           });

           sock.on('close', function(data) {
               

               if (m_disconnectCallback !== undefined){
                   m_disconnectCallback(m_clientList[sock._peername.address + ":" + sock._peername.port]);
               }
               else{
                   console.log('Client disconnected : ' + sock._peername.address + ' : ' + sock._peername.port);
               }

               delete m_clientList[sock._peername.address + ":" + sock._peername.port.toString()];
               sock.destroy();
           });

       } 
    }
}

// ## Callbacks

exports.setMessageCallback = function (callback){

    m_messageCallback = callback;
}

exports.setConnectionCallback = function (callback){

    m_connectionCallback = callback;
}

exports.setDisconnectCallback = function (callback){

    m_disconnectCallback = callback;
}

// ## Send or broadcast without a socket object

exports.send = function(ssid, message){

    for (var c in m_clientList){

        if (m_clientList[c].ssid === ssid){

            m_clientList[c].send(message);
            return;
        }
    }
}

exports.broadcast = function(message){

    for (var c in m_clientList){

        m_clientList[c].send(message);
    }
}

exports.broadcastToNodes = function (nodes, data){

    for (var c in m_clientList){

        console.log("Node : " + m_clientList[c].ssid)
        
        if (nodes.indexOf(m_clientList[c].ssid) != -1) {
            console.log("    |-> Brodcasting to this node");
            m_clientList[c].send(data);
        }
    }
}

// ## Internal function for data received processing

function dataReceived(dt, client){

    var data = dt;

    try{

        data = JSON.parse(dt);
    }
    catch (E){

        console.log("ERROR : " + E);
    }

    // Hearthbeat ?
    if (data.type === "HB"){

        client.resetTimeout();
        try{
            client.send({type : "HB-ACK", body : data.body});   
        }
        catch (err){
            console.log("Can't write HB-ACK : " + err);
        }
    }
    else if (data.type === "HB-negotiation"){

        console.log("Heartbeat negotiated to : " + data.body + " ms");
        client.setHeartbeat(data.body);
    }

    else if (m_messageCallback !== undefined){

        m_messageCallback(client,data);
    }
}
